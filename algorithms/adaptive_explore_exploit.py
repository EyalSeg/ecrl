from copy import deepcopy

from numpy import round
from numpy.random import choice
from typing import Union

from toolz import do

from algorithms.algorithm_typing import *

T = TypeVar("T")


class AdaptiveExploreExploit:
    def __init__(self, initializer: Initializer, popsize: int, rollout: Rollout,
                 exploit_fitness: FitnessMeasure[Trajectory], explore_fitness_from_archive: ArchiveToBatchFitness[T],
                 archive: Archive[T], ratio_growth: float, ratio_decay: float, survivor_selection: SurvivorSelector,
                 elite_extractor: EliteExtractor, behavior_characteristic: BehaviorCharacteristic[T], mutator:Mutator,
                 explore_exploit_ratio: float = 0.5,
                 ):
        self.initializer = initializer
        self.rollout = rollout
        self.popsize = popsize
        self.exploit_fitness = exploit_fitness
        self.explore_fitness_from_archive = explore_fitness_from_archive
        self.extract_elite = elite_extractor
        self.behavior_characteristic = behavior_characteristic
        self.archive = archive
        self.survivor_selection = survivor_selection
        self.mutate = mutator

        self.explore_exploit_ratio = explore_exploit_ratio
        self.ratio_growth = ratio_growth
        self.ratio_decay = ratio_decay

        self.population: List[Agent] = []
        self.population_exploit_fitnesses: List[float] = []
        self.population_explore_fitnesses: List[float] = []

        self.elite: Union[Agent, None] = None
        self.elite_fitness: Union[float, None] = None

    def generation(self):
        if not self.population:
            self.population = [self.initializer() for _ in range(self.popsize)]
        else:
            n_children = self.popsize - 1   # one for the elite
            n_explore_children = int(round(n_children * self.explore_exploit_ratio))
            n_exploit_children = n_children - n_explore_children

            self.population = \
                [self.elite] + \
                self.get_children(n_explore_children, self.population_explore_fitnesses) + \
                self.get_children(n_exploit_children, self.population_exploit_fitnesses)

        trajectories = [self.rollout(specimen) for specimen in self.population]
        self.population_exploit_fitnesses = [self.exploit_fitness(traj) for traj in trajectories]

        self._update_elite(
            *self.extract_elite(self.population, self.population_exploit_fitnesses)
        )

        bcs = [self.behavior_characteristic(traj) for traj in trajectories]
        explore_fitness: BatchFitnessMeasure[T] = self.explore_fitness_from_archive(self.archive)
        self.population_explore_fitnesses = explore_fitness(bcs)

        self.archive.store(bcs)

    def _update_elite(self, new_elite, new_elite_fitness):
        if self.elite is not None and self.elite != new_elite:
            # We found a new elite - exploit!
            self.explore_exploit_ratio -= self.ratio_decay
            self.explore_exploit_ratio = max(self.explore_exploit_ratio, 0)
        else:
            # We did not find a new elite - explore!
            self.explore_exploit_ratio += self.ratio_growth
            self.explore_exploit_ratio = min(self.explore_exploit_ratio, 1)

        self.elite = new_elite
        self.elite_fitness = new_elite_fitness

    def get_children(self, n_children, pop_fitnesses):
        survivors = self.survivor_selection(self.population, pop_fitnesses)
        parents = choice(survivors, n_children, replace=True)

        children = [do(self.mutate, deepcopy(parent)) for parent in parents]
        return children






